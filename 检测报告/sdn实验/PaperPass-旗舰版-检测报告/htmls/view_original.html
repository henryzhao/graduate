<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="">
    <meta name="description" content="">
    <title>查看原文</title>
    <link href="css/bootstrap.css" rel="stylesheet" />
    <link href="css/style.css" rel="stylesheet" />
</head>
<body>
<div class="bg-grey PLR40">

    <div class="paper-txt P30">
        <p class="text-idt25" data-id="1">四、SDN虚拟环境搭建</p><p class="text-idt25" data-id="2">4.1实验的网络技术</p><p class="text-idt25" data-id="3">4.1.1 Mininet仿真平台</p><p class="text-idt25" data-id="4">使用源码编译安装的方式安装mininet，安装步骤如下：</p><p class="text-idt25" data-id="5">更新软件</p><p class="text-idt25" data-id="6"># apt-get update</p><p class="text-idt25" data-id="7"># apt-get upgrade</p><p class="text-idt25" data-id="8">如果ubuntu没有安装git，需要安装</p><p class="text-idt25" data-id="9"># apt install git</p><p class="text-idt25" data-id="10">从github上获取Mininet源码</p><p class="text-idt25" data-id="11"># git clone git://github.com/mininet/mininet</p><p class="text-idt25" data-id="12">获取源码后可以查看当前获取的Mininet版本，在~/mininet目录下，可以通过git tag 命令列出所有可用的Mininet版本</p><p class="text-idt25" data-id="13"># cd mininet</p><p class="text-idt25" data-id="14"># git tag</p><p class="text-idt25" data-id="15">或者你想安装的任意版本</p><p class="text-idt25" data-id="16"># git checkout -b 2.2.1 2.2.1</p><p class="text-idt25" data-id="17">获取源码树并安装Mininet</p><p class="text-idt25" data-id="18">#cat INSTALL</p><p class="text-idt25" data-id="19">切换到mininet文件下：</p><p class="text-idt25" data-id="20"># cd mininet 注意：如果前面进行了cd mininet此时则不需要再cd mininet</p><p class="text-idt25" data-id="21">这里有多个安装选项：mininet/util/install.sh[options]</p><p class="text-idt25" data-id="22">“-a”：完整安装包括Mininet VM，还包括如Open vSwitch等依赖关系软件，以及像的OpenFlow Wireshark和POX。默认情况下，这些工具将被安装在你的home目录中。完整安装命令：</p><p class="text-idt25" data-id="23"># ./util/install.sh -a 我选择的是完整安装，装完这步可以跳到（4）了</p><p class="text-idt25" data-id="24">“-nfv”：安装Mininet、基于OpenFlow的交换机和Open vSwitch。命令：</p><p class="text-idt25" data-id="25"># ./util/install.sh –nfv</p><p class="text-idt25" data-id="26">“-s mydir” ：使用此选项可将源代码建立在一个指定的目录中，而不是在home目录中。</p><p class="text-idt25" data-id="27">#./util/install.sh -s mydir</p><p class="text-idt25" data-id="28">另外，你只想安装OpenFlow1.3和Open vSwitch2.3.0，可以使用安装命令：</p><p class="text-idt25" data-id="29"># mininet/util/install.sh –n3V 2.3.0</p><p class="text-idt25" data-id="30">安装完成后可通过简单的命令测试Mininet的基本功能</p><p class="text-idt25" data-id="31"># sudo mn --test pingall</p><p class="text-idt25" data-id="32">可以查看安装好的Mininet版本：</p><p class="text-idt25" data-id="33"># mn --version</p><p class="text-idt25" data-id="34">4.1.2 Ryu控制器</p><p class="text-idt25" data-id="35">安装RYU，具体步骤如下：</p><p class="text-idt25" data-id="36">（1）安装前先更新一下系统：</p><p class="text-idt25" data-id="37">sudo apt-get upgrade</p><p class="text-idt25" data-id="38">（2）安装RYU，需要安装一些python的套件：</p><p class="text-idt25" data-id="39">$ sudo apt-get install python-pip python-dev build-essential</p><p class="text-idt25" data-id="40">$ sudo pip install --upgrade pip</p><p class="text-idt25" data-id="41">$ sudo apt-get install python-eventlet</p><p class="text-idt25" data-id="42">$ sudo apt-get install python-routes</p><p class="text-idt25" data-id="43">$ sudo apt-get install python-webob</p><p class="text-idt25" data-id="44">$ sudo apt-get install python-paramiko</p><p class="text-idt25" data-id="45">（3）安装RYU，采用获取源码的方式，也可以采用pip安装方式（ pip install ryu 即可）</p><p class="text-idt25" data-id="46">$ git clone git://github.com/osrg/ryu.git</p><p class="text-idt25" data-id="47">$ cd ryu</p><p class="text-idt25" data-id="48">$ sudo pip install -r tools/pip-requires</p><p class="text-idt25" data-id="49">$ sudo python setup.py install</p><p class="text-idt25" data-id="50">测试</p><p class="text-idt25" data-id="51">$ cd</p><p class="text-idt25" data-id="52">$ ryu-manager</p><p class="text-idt25" data-id="53">4.2实验的设计过程</p><p class="text-idt25" data-id="54">4.2.1 拓扑结构设计</p><p class="text-idt25" data-id="55">数据中心是对 SDN应用较快较广泛的地方，其中最迫切地需求是为服务器群组提供高效的双向带宽互联，通常采用层次性多根网络拓扑，其中胖树（ fat- tree）结构因其简单易用而得到广泛应用，本实验基于胖树结构的 SDN网络进行仿真，胖树网络的好处是具有一个多层次的树状拓扑结构固有的容错能力。</p><p class="text-idt25" data-id="56">Fat-tree拓扑结构是由MIT的Al-Fares等人在改进传统树形结构性能的基础上提出的，属于switch-only型拓扑。整个拓扑网络分为三个层次，自下而上分别为边缘层（ Edge）、汇聚层（ Aggregate）以及核心层（ Core），其中汇聚层交换机与边缘层交换机构成一个 pod。Fat-tree构建拓扑规则如下： FatTree拓扑中包含的 Pod数目为 k，每一个 pod连接的 sever数目为(〖 k/2)〗^2，每一个 pod内的边缘交换机及聚合交换机数量均为 k/2，核心交换机数量为(〖 k/2)〗^2，网络中每一个交换机的端口数量为 k，网络所能支持的服务器总数为 k^3/4</p><p class="text-idt25" data-id="57"> FatTree结构采用水平扩展的方式，当拓扑中所包含的 pod数目增加，交换机的端口数目增加时， FatTree拓扑能够支持更多的服务器，满足数据中心的扩展需求，如 k=48时， FatTree能够支持的服务器数目为27648。</p><p class="text-idt25" data-id="58">FatTree结构通过在核心层多条链路实现负载的及时处理，避免网络热点；通过在pod内合理分流，避免过载问题。</p><p class="text-idt25" data-id="59">FatTree对分带宽随着网络规模的扩展而增大，因此能够为数据中心提供高吞吐传输服务；不同pod之间的服务器间通信，源、目的节点之间具有多条并行路径，因此网络的容错性能良好，一般不会出现单点故障；采用商用设备取代高性能交换设备，大幅度降低网络设备开销；网络直径小，能够保证视频、在线会与等服务对网络实时性的要求；拓扑结构规则、对称，利于网络布线及自动化配置、优化升级等。</p><p class="text-idt25" data-id="60">Fat-Tree结构也存在一定的缺陷：Fat-Tree结构的扩展规模在理论上受限于核心交换机的端口数目，不利于数据中心的长期发展要求；对于Pod内部，Fat-Tree容错性能差，对底层交换设备故障非常敏感，当底层交换设备故障时，难以保证服务质量；拓扑结构的特点决定了网络不能很好的支持one-to-all及all-to-all网络通信模式，不利于部署MapReduce、Dryad等现代高性能应用；网络中交换机与服务器的比值较大，在一定程度上使得网络设备成本依然很高，不利于企业的经济发展。</p><p class="text-idt25" data-id="61">一个简单的基于两个数据中心的网络拓扑如下图：</p><p class="text-idt25" data-id="62">图中c1和c2为核心交换机，a1-a4为聚合交换机，e1-e4为边缘交换机，h1-h8为主机。</p><p class="text-idt25" data-id="63"> Mininet提供了一个内置的可视化工具 miniedit，因此可以直接使用可视化工具通过拖拽图标与修改属性的方式搭建出理想的拓扑，也可以通过编写 python文件来自定义拓扑结构。</p><p class="text-idt25" data-id="64">使用Mininet设计模拟不同网络数据中心拓扑，可以用来分析网络的总流量，而且除此之外，还可以通过负载均衡策略来保证数据中心的可用性。不同数据中心网络拓扑管理设计，主要是基于胖树（ Fat- Tree）拓扑创建网络，胖树网络的好处是具有一个多层次的树状拓扑结构固有的容错能力。</p><p class="text-idt25" data-id="65">构造自定义拓扑主要使用以下三个函数：</p><p class="text-idt25" data-id="66">增加主机</p><p class="text-idt25" data-id="67">addHost(’hostname’)</p><p class="text-idt25" data-id="68">增加交换机</p><p class="text-idt25" data-id="69">addSwitch(’switchname’)</p><p class="text-idt25" data-id="70">增加链路</p><p class="text-idt25" data-id="71">addLink(node1，node2，node1_port，node2_port)</p><p class="text-idt25" data-id="72">4.2.3 开发Ryu应用</p><p class="text-idt25" data-id="73">Ryu是控制器，通过下发流表给交换机来进行数据包转发决策。首先，我们应该知道：</p><p class="text-idt25" data-id="74">控制器和交换机握手完成之后，一条默认流表项应该被添加进流表。它的作用是为了让交换机发送Packet-In消息。这条默认流表项被称为Table-Miss，不过Table-Miss不是默认存在的，他也是由控制器下发的。我们在控制器代码里面定义的 MAC地址表是只有控制器知道的，对于交换机来说，只有流表才能帮助它转发，所以控制器要给交换机下发流表，如果你不在交换机添加详细的流表项，那么你应该让交换机收到每一个数据包都上报控制器，由控制器下发 Packet- Out报文进行处理，否则数据包会被丢弃，控制器下发的流表项包含了应该对数据包进行的动作。</p><p class="text-idt25" data-id="75">一、编写Ryu组件addtag.py，功能是实现打标签。</p><p class="text-idt25" data-id="76">首先是继承Ryu的app_manager.RyuApp基类，然后定义以下函数：</p><p class="text-idt25" data-id="77">switch_features_handler函数的作用就是下发一条Table miss流表，用于将不知如何转发的数据包上报控制器。鉴于流表项的特殊性，我们在交换机向控制器发送完自身信息的时候让控制器下发这条流表项，这个时候修饰器会调用这个函数。这条流表项需要具有以下特点：优先级最低，保证最后匹配；必须要能匹配所有数据包。所以我们指定了一个空的match，并且把这条流表项的优先级设置为0，将OFPCML_NO_BUFFER指定为max_len。调用的add_flow函数是我们自己定义的。</p><p class="text-idt25" data-id="78">add_flow函数的参数表较多，因为这些在下发流表的时候调用的FlowMod类里面都要用到。所以简要的介绍一下用到的参数（括号内是默认值）:datapath：是传来数据的交换机，内有ID编号;priority(0)：指定流表项的优先级，影响匹配顺序，优先级越大越先匹配;match(None)：流表项要匹配的内容，比如进入接口，目的地址等;buffer_id（ofproto_v1_3.OFP_NO_BUFFER）:指定在OpenFlow交换机上缓冲的数据包的缓冲区ID。当未指定缓冲区ID时，请设置OFP_NO_BUFFER;instructions ([]):交换机要执行的指令列表。指定好所有的值最后就调用send_msg来发送流表项。</p><p class="text-idt25" data-id="79">delete_flow函数即负责删除流的函数</p><p class="text-idt25" data-id="80"> push_ tag_ action函数实际定义了一个操作数据包的动作，该动作负责添加 vlan或者修改 vlan，本实验以链路号作为标签，把标签保存在 vlan中，因此 vlan的值即为链路号的有序组合，在该函数中，需要编写代码来实现打标签的逻辑，比如需要判断链路号是否需要作为标签存入 vlan中（当该链路是唯一可达路径上的一部分时，该链路号不需要作为标签保存），需要判断前面是否已经存入了标签来决定保存该标签的方式等。</p><p class="text-idt25" data-id="81">_ packet_ in_ handler函数要完成的功能比较多，首先它需要获取进入的接口，源和目的 MAC地址，然后填充 MAC地址表，注意一个细节，我们需要根据交换机编号和源地址来指定接口，因为同一个接口可能会对应不同的 MAC地址。然后做一下判断，如果MAC地址表里面没有目的MAC地址，就设置为广播；有地址就设置为出接口。然后是添加流表项操作，我们只能在找到了目的地的情况下才添加流表项，对于本次实验来说，定义流表项的动作集时，填充的最关键的动作就是打标签的动作，调用 push_ tag_ action函数定义该动作。这里有个概念buffer_id需要理解，buffer_id: 指定openflow交换机上封包对应的缓冲区，若不需要，则指定为OFP_NO_BUFFER。openflow中buffer_id分别在三类消息中定义，并且起到的作用均是不同的，第一类、Packetin消息：用于标记缓存在交换机中的数据报文 id，如报文被 action上送到控制器中 maxlen字段或者 table_ miss消息限制长度，而通过 bufferid将报文缓存在交换机中，以便被另外两种消息来调用；第二类、Packetout消息：用于控制器将原先buffer在交换机中的报文，通过Packetout个形式从交换机的某个物理口送出去；第三类、Flowmod消息：如果 flowmod中带有 bufferid，那么说明这个 flowmod需要做两件事情，第一是正常下发一条 flow，其次是把交换机中先前 buffer的那个数据报文， Packetout到 table来匹配一次下的这条 flow；以上两个指令都是通过这个带有bufferid的消息执行的，不需要控制器另外下packet_out消息，这种设计思路是非常巧妙的。</p><p class="text-idt25" data-id="82">二、编写Ryu组件getpath.py，功能是提取数据包的标签，回溯路径并记录当前时间。</p><p class="text-idt25" data-id="83">该组件的目的不是定义数据包转发规则，而是读取数据包内容，因此_ packet_ in_ handler函数中主要需要实现的是，按照保存标签的逻辑提取出标签并组成队列，对队列中相邻的元素进行树的广度优先遍历来找出两个元素之间的唯一路径，最后将这些路径连接起来组成一条完整的路径。</p><p class="text-idt25" data-id="84">4.2.4 Mininet与Ryu连接</p><p class="text-idt25" data-id="85">本实验定义了胖树网络拓扑， topo. py，在该文件中，使用 net. addController函数（该函数有两个参数，第一个参数为控制器的名称，第二个参数为控制器的监听端口）添加了控制该拓扑的两个控制器 con0（监听的端口号为6633）和 con1（监听的端口号为6634），让 con0与拓扑中的所有交换机相连， con1则只与边缘交换机相连。</p><p class="text-idt25" data-id="86">打开终端1，运行：sudo ryu-manager addtag.py --ofp-tcp-listen-port=6633</p><p class="text-idt25" data-id="87">打开终端2，运行：sudo ryu-manager getpath.py --ofp-tcp-listen-port=6653</p><p class="text-idt25" data-id="88">打开终端3，运行： sudo python build_ topo. py进入 mininet终端，在 mininet的终端可进行数据包的 ping操作，如果在实现组件的时候有将结果展示到终端，那么可以在终端1，2看到相应的结果。</p>        <div class="paper-footer">
            <p>检测报告由<a href="http://www.paperpass.com/" target="_black">PaperPass</a>文献相似度检测系统生成</p>
            <p>Copyright © 2007-2018 PaperPass</p>
        </div>
    </div>

</div>
</body>
</html>
